var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",resolution:9,minlength:3,optimize:!0,fastupdate:!0,cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"/docs/introduction/",title:"Introduction",description:"",content:""}),a.add({id:1,href:"/docs/introduction/overview/",title:"Overview",description:"Fixture Monkey # Fixture Monkey is a Java \u0026amp; Kotlin library designed to generate controllable arbitrary test objects.\nIt focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you\u0026rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.\n Why use Fixture Monkey? # 1. Simplicity # Product actual = fixtureMonkey.",content:"Fixture Monkey # Fixture Monkey is a Java \u0026amp; Kotlin library designed to generate controllable arbitrary test objects.\nIt focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you\u0026rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.\n Why use Fixture Monkey? # 1. Simplicity # Product actual = fixtureMonkey.giveMeOne(Product.class);  Fixture Monkey makes test object generation remarkably easy. With just one line of code, you can effortlessly generate any kind of test object you desire. It simplifies the given section of the test, enabling you to write tests faster and more easily. You also don\u0026rsquo;t need to change the production code or test environment.\n2. Reusability # ArbitraryBuilder\u0026lt;Product\u0026gt; actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;id\u0026quot;, 1000L) .set(\u0026quot;productName\u0026quot;, \u0026quot;Book\u0026quot;);  Fixture Monkey allows you to reuse configurations of instances across multiple tests, saving you time and effort. Complex specifications only need to be defined once within your builder and can then be reused to obtain instances.\nFurthermore, there are additional features that boost reusability. For more details on these features, refer to the sections on \u0026lsquo;Registering Default ArbitraryBuilder\u0026rsquo; and \u0026lsquo;InnerSpec\u0026rsquo;.\n3. Randomness # ArbitraryBuilder\u0026lt;Product\u0026gt; actual = fixtureMonkey.giveMeBuilder(Product.class); then(actual.sample()).isNotEqualTo(actual.sample());  Fixture Monkey helps tests become more dynamic by generating test objects with random values. This leads to undercovering edge cases that might remain hidden when using static data.\n4. Versatility # // inheritance class Foo { String foo; } class Bar extends Foo { String bar; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); Bar bar = FixtureMonkey.create().giveMeone(Bar.class); // circular-reference class Foo { String value; Foo foo; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); // anonymous objects interface Foo { Bar getBar(); } class Bar { String value; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class);  Fixture Monkey is capable to create any kind of object you can imagine. It supports generating basic objects such as lists, nested collections, enums and generic types. It also handles more advanced scenarios, including objects with inheritance relationships, circular-referenced objects, and anonymous objects that implement interfaces.\n Proven Effectiveness # Fixture Monkey was originally developed as an in-house library at Naver and played a crucial role in simplifying test object generation for the Plasma project. The Plasma project aimed to revolutionize Naver Pay\u0026rsquo;s architecture, which is the most used mobile payment service in South Korea with a daily active user count of 261,400.\nThe project required thorough testing of complex business requirements, and with Fixture Monkey\u0026rsquo;s assistance, the team efficiently wrote over 10,000 tests, uncovering critical edge cases and ensuring the system\u0026rsquo;s reliability. Now available as an open-source library, developers worldwide can take advantage of Fixture Monkey to simplify their test codes and build robust applications with confidence.\n"}),a.add({id:2,href:"/docs/get-started/",title:"Getting Started",description:"",content:""}),a.add({id:3,href:"/docs/get-started/requirements/",title:"Requirements",description:"ðŸ’¡  Fixture Monkey is designed for test environments. It is not recommended for production use.   Prerequisites #  Java 8 or higher JUnit 5 platform jqwik 1.3.9   Dependencies #    Dependency Description     fixture-monkey Core library   fixture-monkey-starter Starter dependency for fixture monkey   fixture-monkey-kotlin Kotlin support   fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin    fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.",content:"ðŸ’¡  Fixture Monkey is designed for test environments. It is not recommended for production use.   Prerequisites #  Java 8 or higher JUnit 5 platform jqwik 1.3.9   Dependencies #    Dependency Description     fixture-monkey Core library   fixture-monkey-starter Starter dependency for fixture monkey   fixture-monkey-kotlin Kotlin support   fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin    fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.\nFor Kotlin environments, you can use fixture-monkey-starter-kotlin\nGradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-starter:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   Third party library support #    Dependency Description     fixture-monkey-jackson Jackson support   fixture-monkey-jakarta-validation Jakarta validation support   fixture-monkey-javax-validation Javax validation support   fixture-monkey-mockito Mockito support   fixture-monkey-autoparams Autoparams support    "}),a.add({id:4,href:"/docs/get-started/creating-test-objects/",title:"Creating test objects",description:"Consider a scenario where you need a test fixture for a Product class, as shown below:\nðŸ’¡  lombok.anyConstructor.addConstructorProperties=true should be added in lombok.config   @Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; ProductType productType; Map\u0026lt;Integer, String\u0026gt; merchantInfo; }  (Note that the Lombok annotation @Value is used to make Immutable classes. If you\u0026rsquo;re working in an environment without Lombok, go to creating test objects without lombok)",content:"Consider a scenario where you need a test fixture for a Product class, as shown below:\nðŸ’¡  lombok.anyConstructor.addConstructorProperties=true should be added in lombok.config   @Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; ProductType productType; Map\u0026lt;Integer, String\u0026gt; merchantInfo; }  (Note that the Lombok annotation @Value is used to make Immutable classes. If you\u0026rsquo;re working in an environment without Lombok, go to creating test objects without lombok)\nWith the Fixture Monkey library, generating an instance of Product becomes remarkably simple, requiring just few lines of code.\n@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); }  First, create a FixtureMonkey instance that facilitates the creation of test fixtures. There are several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.\nHere we are configuring the objectIntrospector to use ConstructorPropertiesArbitraryIntrospector, which means that the object will be constructed using the constructor annotated with @ConstructorProperties. An Introspector defines how Fixture Monkey generates objects.\nFor ConstructorPropertiesArbitraryIntrospector, the generated class should have a constructor with @ConstructorProperties or you can add lombok.anyConstructor.addConstructorProperties=true in the lombok.config file. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)\nNext, use the giveMeOne() method with the desired test class type to generate an instance of the specified type.\nAs evident from the then section, an instance of the Product class is created.\n"}),a.add({id:5,href:"/docs/get-started/creating-test-objects-without-lombok/",title:"Creating test objects without Lombok",description:"ðŸ’¡  If you're using Lombok in your project, feel free to move on to the next page.   Consider a scenario where you need a test fixture for a Product class, as shown below:\npublic class Product { private long id; private String productName; private long price; private List\u0026lt;String\u0026gt; options; private Instant createdAt; private ProductType productType; private Map\u0026lt;Integer, String\u0026gt; merchantInfo; public Product() { } public void setId(long id) { this.",content:"ðŸ’¡  If you're using Lombok in your project, feel free to move on to the next page.   Consider a scenario where you need a test fixture for a Product class, as shown below:\npublic class Product { private long id; private String productName; private long price; private List\u0026lt;String\u0026gt; options; private Instant createdAt; private ProductType productType; private Map\u0026lt;Integer, String\u0026gt; merchantInfo; public Product() { } public void setId(long id) { this.id = id; } public void setProductName(String productName) { this.productName = productName; } public void setPrice(long price) { this.price = price; } public void setOptions(List\u0026lt;String\u0026gt; options) { this.options = options; } public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; } public void setProductType(ProductType productType) { this.productType = productType; } public void setMerchantInfo(Map\u0026lt;Integer, String\u0026gt; merchantInfo) { this.merchantInfo = merchantInfo; } }  With the Fixture Monkey library, generating an instance of Product becomes remarkably simple, requiring just few lines of code.\n@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); }  First, create a FixtureMonkey instance that facilitates the creation of test fixtures. You can use create() to generate a Fixture Monkey instance with default options. There are also several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.\nFixture Monkey uses BeanArbitraryIntrospector as its default method for generating objects. An Introspector defines how Fixture Monkey generates objects.\nFor BeanArbitraryIntrospector, the class being generated needs to have a no-args constructor and setters. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)\nNext, use the giveMeOne() method with the desired test class type to generate an instance of the specified type.\nAs evident from the then section, an instance of the Product class is created.\n"}),a.add({id:6,href:"/docs/get-started/adding-bean-validation/",title:"Adding Bean Validation",description:"Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class.\nFixture Monkey supports constraint annotations from the jakarta.validation.constraints and javax.validation.constraints packages.\nTo enable this feature, you need to add the fixture-monkey-jakarta-validation dependency (or fixture-monkey-javax-validation if you are using javax.validation.constraints) to your project as follows:\nGradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  Fixture Monkey provides additional features as plugins.",content:"Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class.\nFixture Monkey supports constraint annotations from the jakarta.validation.constraints and javax.validation.constraints packages.\nTo enable this feature, you need to add the fixture-monkey-jakarta-validation dependency (or fixture-monkey-javax-validation if you are using javax.validation.constraints) to your project as follows:\nGradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  Fixture Monkey provides additional features as plugins.\nTo generate objects based on Bean Validation annotations, you need to add the JakartaValidationPlugin (or JavaxValidationPlugin if you are using javax.validation.constraints) option to FixtureMonkey as shown below. If you\u0026rsquo;ve added the fixture-monkey-starter dependency, it\u0026rsquo;s already in place.\nFixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) // or new JavaxValidationPlugin() .build();  Let\u0026rsquo;s assume that we have added several validation annotations to the previous Product class.\n@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; }  With the FixtureMonkey instance we created earlier, we can now generate valid objects:\n@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -\u0026gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); }  From the assertions, it\u0026rsquo;s clear that the object created with FixtureMonkey meets all the validation annotation requirements.\n"}),a.add({id:7,href:"/docs/get-started/customizing-objects/",title:"Customizing objects",description:"Suppose you need to customize your test fixture for a specific unit test. In that case, you can use Fixture Monkey to generate a builder and further customize it.\n@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; }  For example, for a certain test you might need a Product instance with an id of 1,000.\nIn order to do this, you can get a type builder from fixture monkey with the giveMeBuilder method.",content:"Suppose you need to customize your test fixture for a specific unit test. In that case, you can use Fixture Monkey to generate a builder and further customize it.\n@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; }  For example, for a certain test you might need a Product instance with an id of 1,000.\nIn order to do this, you can get a type builder from fixture monkey with the giveMeBuilder method. The Builder allows chaining additional method calls to customize your fixture. In this case you can use the set() function to set the id to 1,000. From the Builder use sample() to get an instance from the builder.\n@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); long id = 1000; // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;id\u0026quot;, id) .sample(); // then then(actual.getId()).isEqualTo(1000); }  In the example above, you can see that the field id is set to a value you desire.\nYou can also use Fixture Monkey to work with fields that are collections. For instance, you might want the list \u0026ldquo;options\u0026rdquo; to have a specific size, and you might want a certain element of it to have a certain value.\n@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026quot;options\u0026quot;, 3) .set(\u0026quot;options[1]\u0026quot;, \u0026quot;red\u0026quot;) .sample(); // then then(actual.getOptions()).hasSize(3); then(actual.getOptions().get(1)).isEqualTo(\u0026quot;red\u0026quot;); }  You can specify the size of a certain collection (list, set, map) and set an element to a specific value using the set() function, and then get your instance by calling the sample() method.\nFor more examples of how to select properties with expressions and set property values, you can go to the customizing section.\n"}),a.add({id:8,href:"/docs/get-started/creating-objects-in-kotlin/",title:"Creating objects in Kotlin",description:"Fixture Monkey also supports generating classes written in Kotlin code.\nIn order to do this, first make sure you added the fixture-monkey-kotlin-starter dependency.\nThen we can add the Kotlin Plugin, to enable additional features of fixture monkey that support using Kotlin.\n@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() }  The Kotlin plugin changes the default ObjectIntrospector to PrimaryConstructorArbitraryIntrospector, which generates Kotlin classes with their primary constructor.",content:"Fixture Monkey also supports generating classes written in Kotlin code.\nIn order to do this, first make sure you added the fixture-monkey-kotlin-starter dependency.\nThen we can add the Kotlin Plugin, to enable additional features of fixture monkey that support using Kotlin.\n@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() }  The Kotlin plugin changes the default ObjectIntrospector to PrimaryConstructorArbitraryIntrospector, which generates Kotlin classes with their primary constructor.\nSuppose you have a Kotlin class like this:\ndata class Product ( val id: Long, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant, val productType: ProductType, val merchantInfo: Map\u0026lt;Integer, String\u0026gt; )  You can generate your Kotlin class just like when you did in Java.\nIf you are writing your test code in Kotlin, one difference is that you can use giveMeOne() without writing the class name, unlike java when you had to write Product.class.\nThe following code shows how to generate objects in kotlin:\n@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() // when val actual: Product = fixtureMonkey.giveMeOne() // then then(actual).isNotNull }  The Kotlin plugin also lets you use a new way to reference the property to customize.\n@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build(); // when val actual = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::id, 1000L) .sizeExp(Product::options, 3) .setExp(Product::options[1], \u0026quot;red\u0026quot;) .sample() // then then (actual.id).isEqualTo(1000L) then (actual.options).hasSize(3) then (actual.options[1]).isEqualTo(\u0026quot;red\u0026quot;) }  Using the setExp() method instead of the set() method, you can specify property assignments using Kotlin\u0026rsquo;s property reference syntax The pages under Kotlin Plugin introduces more features that are provided by the Kotlin plugin.\n"}),a.add({id:9,href:"/docs/generating-objects/",title:"Generating Objects",description:"",content:""}),a.add({id:10,href:"/docs/generating-objects/fixture-monkey/",title:"FixtureMonkey",description:"To generate test fixtures, the first step is to create a FixtureMonkey instance, which facilitates the creation of test fixtures.\nYou can use the create() method to generate a FixtureMonkey instance with default options. For Kotlin environments, add the Kotlin plugin.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.create();  val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build()   If you want to add some options for creating or customizing the test fixtures, you can add them using the FixtureMonkey builder.",content:"To generate test fixtures, the first step is to create a FixtureMonkey instance, which facilitates the creation of test fixtures.\nYou can use the create() method to generate a FixtureMonkey instance with default options. For Kotlin environments, add the Kotlin plugin.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.create();  val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build()   If you want to add some options for creating or customizing the test fixtures, you can add them using the FixtureMonkey builder.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() + options... .build();  val fixtureMonkey = FixtureMonkey.builder() + options... .build()   For information on what options are available, see the Fixture Monkey Options section.\nGenerating instances # The FixtureMonkey class provides several methods to help create test objects of the required type.\ngiveMeOne() # If you need an instance of a certain type, you can use giveMeOne(). Pass either a class or a type reference.\nJava  Kotlin    Product product = fixtureMonkey.giveMeOne(Product.class); List\u0026lt;String\u0026gt; strList = fixtureMonkey.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {});  val product: Product = fixtureMonkey.giveMeOne() val strList: List\u0026lt;String\u0026gt; = fixtureMonkey.giveMeOne()   giveMe() # If you need multiple instances of a certain type, you can use the giveMe() method. You can choose to generate either a stream of instances or a list by specifying the desired size.\nJava  Kotlin    Stream\u0026lt;Product\u0026gt; productStream = fixtureMonkey.giveMe(Product.class); Stream\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListStream = fixtureMonkey.giveMe(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); List\u0026lt;Product\u0026gt; productList = fixtureMonkey.giveMe(Product.class, 3); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListList = fixtureMonkey.giveMe(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}, 3);  val productSequence: Sequence\u0026lt;Product\u0026gt; = fixtureMonkey.giveMe() val strListSequence: Sequence\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMe() val productList: List\u0026lt;Product\u0026gt; = fixtureMonkey.giveMe(3) val strListList: List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMe(3)   giveMeBuilder() # If you need to further customize the instance to be created, you can use giveMeBuilder(). This will return an ArbitraryBuilder of the given type. An ArbitraryBuilder is a class in Fixture Monkey that acts as a builder for an Arbitrary object of the given class.\nJava  Kotlin    ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListBuilder = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {});  val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val strListBuilder: ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMeBuilder()   For cases where you already have a generated instance and want to customize it further, you can also use giveMeBuilder().\nJava  Kotlin    Product product = new Product(1L, \u0026#34;Book\u0026#34;, ...); ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(product);  val product = Product(1L, \u0026#34;Book\u0026#34;, ...) val productBuilder = fixtureMonkey.giveMeBuilder(product)   The generated ArbitraryBuilder can be used for further customization of your fixture. For more information on customization options, see the section on customization objects.\nTo obtain an instance from the ArbitraryBuilder, you can use the sample(), sampleList(), sampleStream() methods of the ArbitraryBuilder.\nJava  Kotlin    ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Product product = productBuilder.sample(); List\u0026lt;Product\u0026gt; productList = productBuilder.sampleList(3); Stream\u0026lt;Product\u0026gt; productStream = productBuilder.sampleStream();  val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val product = productBuilder.sample() val productList = productBuilder.sampleList(3) val productStream = productBuilder.sampleStream()   In cases where you need an Arbitrary itself rather than an instance, you can simply call the build() method.\nJava  Kotlin    ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Arbitrary\u0026lt;Product\u0026gt; productArbitrary = productBuilder.build();  val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val productArbitrary = productBuilder.build()   giveMeArbitrary() # To get an Arbitrary of the specified type, you can use the giveMeArbitrary() method.\nJava  Kotlin    Arbitrary\u0026lt;Product\u0026gt; productArbitrary = fixtureMonkey.giveMeArbitrary(Product.class); Arbitrary\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListArbitrary = fixtureMonkey.giveMeArbitrary(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {});  val productArbitrary: Arbitrary\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeArbitrary() val strListArbitrary: Arbitrary\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMeArbitrary()   "}),a.add({id:11,href:"/docs/generating-objects/introspector/",title:"Introspector",description:"There are a number of ways to create an object. For example, you can initialize an instance of an object using its constructor, or you can use its builder. Fixture Monkey lets you choose which way you want to create your object by providing different Introspectors.\nAn Introspector defines how Fixture Monkey creates objects. Each introspector has some kind of restrictions that the class must have in order for the introspector to generate instances of that class.",content:"There are a number of ways to create an object. For example, you can initialize an instance of an object using its constructor, or you can use its builder. Fixture Monkey lets you choose which way you want to create your object by providing different Introspectors.\nAn Introspector defines how Fixture Monkey creates objects. Each introspector has some kind of restrictions that the class must have in order for the introspector to generate instances of that class.\nYou can change the introspector you use by using the objectIntrospector option of Fixture Monkey.\nBeanArbitraryIntrospector # The BeanArbitraryIntrospector is the default introspector that fixture monkey uses for object creation. It creates new instances using reflection and the setter method, so the class it creates must have a no-args constructor and setters.\nFixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BeanArbitraryIntrospector.INSTANCE) .build();  ConstructorPropertiesArbitraryIntrospector # To generate an object with its given constructor, you can use ConstructorPropertiesArbitraryIntrospector.\nFor ConstructorPropertiesArbitraryIntrospector, the generated class should have a constructor with @ConstructorProperties or the class should be a record type. (Or, if you are using Lombok, you can add lombok.anyConstructor.addConstructorProperties=true to the lombok.config file.)\nWhen you create a record class and have multiple constructors, the constructor with the @ConstructorProperties annotation has priority.\nFixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build();  FieldReflectionArbitraryIntrospector # FieldReflectionArbitraryIntrospector creates new instances with reflection and also sets the fields with reflection. So the class to be generated must have a no-args constructor and one of the getters or setters.\nFixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(FieldReflectionArbitraryIntrospector.INSTANCE) .build();  BuilderArbitraryIntrospector # To generate a class using the class\u0026rsquo;s builder, you can use BuilderArbitraryIntrospector. It requires that the class has a builder.\nFixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BuilderArbitraryIntrospector.INSTANCE) .build();  FailoverArbitraryIntrospector # Sometimes your production code may contain several classes with different configurations, making it difficult to generate all objects with a single introspector. In this case, you can use the FailoverArbitraryIntrospector. This introspector allows you to use multiple introspectors, and it will continue the introspection even if one of the introspectors fails to generate.\nFixtureMonkey sut = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( FieldReflectionArbitraryIntrospector.INSTANCE, ConstructorPropertiesArbitraryIntrospector.INSTANCE ) )) .build();   Additional introspectors have been introduced inside plugins, such as JacksonObjectArbitraryIntrospector or PrimaryConstructorArbitraryIntrospector\n"}),a.add({id:12,href:"/docs/customizing-objects/",title:"Customizing Objects",description:"",content:""}),a.add({id:13,href:"/docs/customizing-objects/apis/",title:"Fixture Customization APIs",description:"Fixture Monkey offers a range of APIs within the ArbitraryBuilder class that enable customization of objects created by it.\nCustomizing Fixtures # set() # The set() method is used to assign values to one or more properties referenced by the expression.\nDifferent types, including Supplier, Arbitrary, ArbitraryBuilder, NOT_NULL, NULL, or Just can be used as the value. Additionally, a certain instance of an object can also be used as the value.",content:"Fixture Monkey offers a range of APIs within the ArbitraryBuilder class that enable customization of objects created by it.\nCustomizing Fixtures # set() # The set() method is used to assign values to one or more properties referenced by the expression.\nDifferent types, including Supplier, Arbitrary, ArbitraryBuilder, NOT_NULL, NULL, or Just can be used as the value. Additionally, a certain instance of an object can also be used as the value.\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;id\u0026#34;, 1000);  fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::id, 1000)   Just #  Using an instance wrapped by Just when using set() makes you set the value directly instead of decomposing. Normally, when you set() a property in ArbitraryBuilder it does not use an instance of the given value, it does a deep copy instead. So, if you need to set with an instance, you can use Values.just(instance) This feature can be useful in cases where you need to set a property to a mock instance when using a mocking framework.\n  Note that you cannot set a child property after setting with Just.\n Product product = fixture.giveMeBuilder(Product.class) * .set(\u0026quot;options\u0026quot;, Values.just(List.of(\u0026quot;red\u0026quot;, \u0026quot;medium\u0026quot;, \u0026quot;adult\u0026quot;)) * .set(\u0026quot;options[0]\u0026quot;, \u0026quot;blue\u0026quot;) * .sample();   For example, the product instance created above, will not have the value \u0026ldquo;blue\u0026rdquo; for the first element of options. It will remain the list given with Just.\n size(), minSize(), maxSize() # The size() method lets you specify the size of container properties. You have the flexibility to either set a precise size or specify a range using the minimum and maximum values.\nAlternatively, you can use minSize() or maxSize() to set only the minimum or maximum container size. (By default, the size range is from 0 to 3 elements.)\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;options\u0026#34;, 5); // size:5  fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;options\u0026#34;, 3, 5); // minSize:3, maxSize:5  fixtureMonkey.giveMeBuilder(Product.class) .minSize(\u0026#34;options\u0026#34;, 3); // minSize:3  fixtureMonkey.giveMeBuilder(Product.class) .maxSize(\u0026#34;options\u0026#34;, 5); // maxSize:5   fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .sizeExp(Product::options, 5) // size:5  fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .sizeExp(Product::options, 3, 5) // minSize:3, maxSize:5  fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .minSizeExp(Product::options, 3) // minSize:3  fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .maxSizeExp(Product::options, 5) // maxSize:5   setNull(), setNotNull() # At times, you might want to ensure that a property is either always set to null or always has a value. In such situations, you can use setNull() or setNotNull().\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .setNull(\u0026#34;id\u0026#34;); fixtureMonkey.giveMeBuilder(Product.class) .setNotNull(\u0026#34;id\u0026#34;);  fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setNullExp(Product::id) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setNotNullExp(Product::id)   setInner() # With setInner() you can apply customizations defined within an InnerSpec instance to your builder. An InnerSpec is a type-independent specification for the customizations to be applied.\nInstances of InnerSpec can be reused to consistently and easily configure nested properties. This feature is particularly beneficial when customizing map properties.\nFor additional guidance, refer to InnerSpec\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, it -\u0026gt; it.entry(1000, \u0026#34;ABC Store\u0026#34;)); fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec)  val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entry(1000, \u0026#34;ABC Store\u0026#34;) } fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec)   setLazy() # The setLazy() function assigns the property a value obtained from the provided Supplier. The Supplier will run every time the ArbitraryBuilder is sampled.\nThis can be particularly useful when you need to generate unique sequential IDs or set the most recent value.\nJava  Kotlin    AtomicReference\u0026lt;Long\u0026gt; variable = new AtomicReference\u0026lt;\u0026gt;(0L); ArbitraryBuilder\u0026lt;Long\u0026gt; builder = fixtureMonkey.giveMeBuilder(Long.class) .setLazy(\u0026#34;$\u0026#34;, () -\u0026gt; variable.getAndSet(variable.get() + 1)); Long actual1 = builder.sample(); // actual1 == 0 Long actual2 = builder.sample(); // actual2 == 1   var variable = 0L val builder = fixtureMonkey.giveMeBuilder(Long::class.java) .setLazy(\u0026#34;$\u0026#34;) { variable++ } val actual1 = builder.sample() // actual1 == 0 val actual2 = builder.sample() // actual2 == 1   setPostCondition() # setPostCondition() can be used when your fixture needs to adhere to a specific condition. This condition can be defined by passing a predicate.\nðŸš¨  Using setPostCondition can incur higher costs for narrow conditions. In such cases, it's recommended to use set instead.   Java  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .setPostCondition(\u0026#34;id\u0026#34;, Long.class, it -\u0026gt; it \u0026gt; 0)  fixtureMonkey.giveMeBuilder(Product::class.java) .setPostConditionExp(Product::id, Long::class.java) { it: Long -\u0026gt; it \u0026gt; 0 }   fixed() # fixed() can be used when you want your arbitrary builder to consistently return instances with the same values every time it is sampled.\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .fixed()  fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .fixed()   limit # For the set(), setLazy(), and setPostCondition() methods, you can include an additional parameter that determines the number of times the customization will be applied. This can be advantageous when the expression refers to multiple properties.\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;options[*]\u0026#34;, \u0026#34;red\u0026#34;, 2); // up to 2 elements in options will be set to \u0026#34;red\u0026#34;   fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;options[*]\u0026#34;, \u0026#34;red\u0026#34;, 2) // up to 2 elements in options will be set to \u0026#34;red\u0026#34;   Expanding Customization using Sampled Results # thenApply() # The thenApply() method becomes handy when you need to customize a field based on the sampled result of the builder. For instance, let\u0026rsquo;s assume you want the \u0026ldquo;productName\u0026rdquo; field to match the generated \u0026ldquo;id\u0026rdquo; of the Product. You can use thenApply() as follows:\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .thenApply((it, builder) -\u0026gt; builder.set(\u0026#34;productName\u0026#34;, it.getId().toString()))  fixtureMonkey.giveMeBuilder(Product::class.java) .thenApply{it, builder -\u0026gt; builder.setExp(Product::productName, it.id.toString())}   acceptIf() # You might also find the need to perform additional customization based on a specific condition. In such cases, you can utilize the acceptIf() method, which applies the customization only when the predicate is satisfied.\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .acceptIf( it -\u0026gt; it.getProductType() == ProductType.CLOTHING, builder -\u0026gt; builder.set(\u0026#34;price\u0026#34;, 1000) )  fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .acceptIf( { it.productType == ProductType.CLOTHING }, { builder -\u0026gt; builder.setExp(Product::price, 1000) } )   Transforming the Type of ArbitraryBuilder # map() # The map() function is used to convert the ArbitraryBuilder type into another type.\nJava  Kotlin    fixtureMonkey.giveMeBuilder(Product.class) .map(Product::getId); // transforms to ArbitraryBuilder\u0026lt;Long\u0026gt;   fixtureMonkey.giveMeBuilder(Product::class.java) .map(Product::id) // transforms to ArbitraryBuilder\u0026lt;Long\u0026gt;   zipWith() # zipWith() becomes useful when you want to merge multiple ArbitraryBuilders to create an ArbitraryBuilder of a different type. You have to define how you intend to combine the builders.\nJava  Kotlin    ArbitraryBuilder\u0026lt;String\u0026gt; stringBuilder = fixtureMonkey.giveMeBuilder(String.class); ArbitraryBuilder\u0026lt;String\u0026gt; zipped = fixtureMonkey.giveMeBuilder(Integer.class) .zipWith(stringBuilder, (integer, string) -\u0026gt; integer + \u0026#34;\u0026#34; + string);  val stringBuilder = fixtureMonkey.giveMeBuilder\u0026lt;String\u0026gt;() val zipped = fixtureMonkey.giveMeBuilder\u0026lt;Int\u0026gt;() .zipWith(stringBuilder) { int, string -\u0026gt; int.toString() + \u0026#34;\u0026#34; + string }   "}),a.add({id:14,href:"/docs/customizing-objects/expressions/",title:"Expressions",description:"When using Fixture Monkey, you have the flexibility to select one or more properties of an object using Fixture Monkey expressions.\nLet\u0026rsquo;s consider an example object structure:\n@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested object; List\u0026lt;Nested\u0026gt; objectList; @Value public static class Nested { String nestedField; } }  Selecting Properties Using Expressions # Selecting the root object: # \u0026quot;$\u0026quot;  Selecting a specific field: # \u0026quot;field\u0026quot;  Selecting a nested field: # \u0026quot;object.",content:"When using Fixture Monkey, you have the flexibility to select one or more properties of an object using Fixture Monkey expressions.\nLet\u0026rsquo;s consider an example object structure:\n@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested object; List\u0026lt;Nested\u0026gt; objectList; @Value public static class Nested { String nestedField; } }  Selecting Properties Using Expressions # Selecting the root object: # \u0026quot;$\u0026quot;  Selecting a specific field: # \u0026quot;field\u0026quot;  Selecting a nested field: # \u0026quot;object.nestedField\u0026quot;  Selecting the n-th element of a collection: # \u0026quot;list[n]\u0026quot;  Selecting all elements of a collection: # \u0026quot;list[*]\u0026quot;  Combining expressions to select a nested field: # \u0026quot;objectList[0].nestedField\u0026quot;  Selecting Collections # Note that for collections, a property will only be selected if it exists within the collection size. For instance, if the list has a size of 2 but the expression references \u0026quot;list[3]\u0026quot;, which is outside the bounds of the list, it will not be selected.\nWhile Fixture Monkey supports selecting elements from lists and sets, there are currently no dedicated expressions for directly setting the elements of a map. However, if you need to customize a map, consider using the InnerSpec method.\nExpression Strict Mode # This option can be turned on to ensure applied expressions strictly match the structure. If any part of an expression is out of bounds or invalid, Fixture Monkey will raise an exception.\nKotlin EXP # By adding the Kotlin plugin, you can select properties using Kotlin\u0026rsquo;s property reference syntax. In Fixture Monkey, this feature is referred to as Kotlin EXP or the Fixture Monkey Kotlin DSL. For further details on its usage, refer to the Kotlin DSL Exp page.\n"}),a.add({id:15,href:"/docs/customizing-objects/arbitrary/",title:"Customizing random values with Arbitrary",description:"Jqwik is a Property-Based Testing library for the JVM environment. Fixture Monkey relies on Jqwik\u0026rsquo;s Arbitrary to generate random values for primitive types such as characters, strings, and integers.\nIn Jqwik, Arbitrary is the core interface used to represent objects that can be generated and shrunk. At times, we might desire our fixture properties to have random values while adhering to certain constraints.\nIn such scenarios, you can achieve this by customizing properties using Fixture Monkey\u0026rsquo;s set() method and assigning an Arbitrary as the value.",content:"Jqwik is a Property-Based Testing library for the JVM environment. Fixture Monkey relies on Jqwik\u0026rsquo;s Arbitrary to generate random values for primitive types such as characters, strings, and integers.\nIn Jqwik, Arbitrary is the core interface used to represent objects that can be generated and shrunk. At times, we might desire our fixture properties to have random values while adhering to certain constraints.\nIn such scenarios, you can achieve this by customizing properties using Fixture Monkey\u0026rsquo;s set() method and assigning an Arbitrary as the value. You can generate an Arbitrary that matches certain conditions, simply by calling static methods in Jqwik\u0026rsquo;s Arbitraries class.\nThe following code example demonstrates ways to customize random values using set() with Arbitrary: Java  Kotlin    Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;id\u0026#34;, Arbitraries.longs().greaterOrEqual(1000)) .set(\u0026#34;productName\u0026#34;, Arbitraries.strings().withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;).ofMaxLength(10)) .set(\u0026#34;productType\u0026#34;, Arbitraries.of(ProductType.CLOTHING, ProductType.ELECTRONICS)) .sample(); then(actual.getId()).isGreaterThanOrEqualTo(1000); then(actual.getProductName()).matches(\u0026#34;^[a-z]+$\u0026#34;); then(actual.getProductName().length()).isLessThanOrEqualTo(10); then(actual.getProductType()).matches(it -\u0026gt; it == ProductType.CLOTHING || it == ProductType.ELECTRONICS);  val actual = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::id, Arbitraries.longs().greaterOrEqual(1000)) .setExp(Product::productName, Arbitraries.strings().withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;).ofMaxLength(10)) .setExp(Product::productType, Arbitraries.of(ProductType.CLOTHING, ProductType.ELECTRONICS)) .sample() then(actual.id).isGreaterThanOrEqualTo(1000) then(actual.productName).matches(\u0026#34;^[a-z]+$\u0026#34;) then(actual.productName.length).isLessThanOrEqualTo(10) then(actual.productType).matches { it -\u0026gt; it === ProductType.CLOTHING || it === ProductType.ELECTRONICS }   For further details about Jqwik and Arbitrary, check out Jqwik User Guide\n"}),a.add({id:16,href:"/docs/customizing-objects/innerspec/",title:"InnerSpec",description:"An InnerSpec is a type-independent specification for the customizations you wish to apply. Using the setInner() method within ArbitraryBuilder, you can apply customizations defined within an InnerSpec instance into your builder.\nInnerSpec holds customization details and can be reused on ArbitraryBuilders. Unlike using expressions used in ArbitraryBuilder, InnerSpec enables a more nested and structured approach.\nAn added advantage of InnerSpec is its ability to customize map properties, unlike normal expressions.",content:"An InnerSpec is a type-independent specification for the customizations you wish to apply. Using the setInner() method within ArbitraryBuilder, you can apply customizations defined within an InnerSpec instance into your builder.\nInnerSpec holds customization details and can be reused on ArbitraryBuilders. Unlike using expressions used in ArbitraryBuilder, InnerSpec enables a more nested and structured approach.\nAn added advantage of InnerSpec is its ability to customize map properties, unlike normal expressions.\nðŸ’¡  Kotlin EXP is not supported for InnerSpec, as it is designed to be type-independent. Instead, you need to specify the property by its name.   Applying InnerSpec to the ArbitraryBuilder # To apply your pre-defined InnerSpec to the builder, use the setInner() method as shown below:\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec().property(\u0026#34;id\u0026#34;, 1000); fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec);  val innerSpec = InnerSpec().property(\u0026#34;id\u0026#34;, 1000) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setInner(innerSpec)   Customizing properties # property() # Similar to the set() method in ArbitraryBuilder, you can customize a property by specifying its name and providing the desired value.\nðŸš¨  Fixture Monkey expressions such as refering elements (`[]`) or nested fields(`.`) are not allowed as the property name. Only the property name itself is allowed.   Java  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, 1000);  val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;, 1000)   size(), minSize(), maxSize() # size(), minSize(), and maxSize() can be used to specify the size of the property.\nAs previously mentioned, InnerSpec defines customizations in a nested manner. You can first select the container property using property() and then proceed to define an innerSpec consumer to set the size.\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.size(5)); // size:5  InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.size(3, 5)); // minSize:3, maxSize:5  InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.minSize(3)); // minSize:3  InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.maxSize(5)); // maxSize:5   val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.size(5) } // size:5  val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.size(3, 5) } // minSize:3, maxSize:5  val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.minSize(3) } // minSize:3  val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.maxSize(5) } // maxSize:5   postCondition() # postCondition() can be used when you require your property to match a specific condition.\nðŸš¨  Using setPostCondition can incur higher costs for narrow conditions. In such cases, it's recommended to use set instead.   Java  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, id -\u0026gt; id.postCondition(Long.class, it -\u0026gt; it \u0026gt; 0));  val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;) { it.postCondition(Long::class.java) { it \u0026gt; 0 }}   inner() # You can also customize a property using another pre-defined InnerSpec with the help of inner().\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, 1000L); fixtureMonkey.giveMeBuilder(Product.class) .setInner( new InnerSpec() .property(\u0026#34;nestedObject\u0026#34;, nestedObject -\u0026gt; nestedObject.inner(innerSpec)) );  val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;, 1000L) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setInner( InnerSpec() .property(\u0026#34;nestedObject\u0026#34;) { it.inner(innerSpec) } )   Customizing list properties # listElement() # Individual elements within lists can be selected using listElement(). This is equivalent to referencing elements with \u0026ldquo;[n]\u0026rdquo; using expressions.\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.listElement(0, \u0026#34;red\u0026#34;));  val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.listElement(0, \u0026#34;red\u0026#34;) }   allListElement() # If you wish to set all elements of the list simultaneously, you can use allListElement(). This is equivalent to referencing elements with \u0026ldquo;[*]\u0026rdquo; using expressions.\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.allListElement(\u0026#34;red\u0026#34;));  val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.allListElement(\u0026#34;red\u0026#34;) }   Customizing map properties # InnerSpec provides special methods for customizing map property entries.\nðŸš¨  Similar to lists, setting a map entry without specifying the size first might lead to no change. Prior to setting a value, ensure that the map property has the intended size.   key(), value(), entry() # You can customize map property entries using key(), value(), and entry() methods. Using key() assigns a specified value to the key of a map entry, while the entry\u0026rsquo;s value remains randomized. Similarly, value() assigns a specified value to the map entry\u0026rsquo;s value, while the key becomes randomized. If you want to specify both the key and value at once, you can use entry().\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.key(1000)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.value(\u0026#34;ABC Store\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entry(1000, \u0026#34;ABC Store\u0026#34;));  val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.key(1000) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.value(\u0026#34;ABC Store\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entry(1000, \u0026#34;ABC Store\u0026#34;) }   keys(), values(), entries() # When setting multiple entries within a map, you can use keys(), values(), and entries() to pass multiple values.\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.keys(1000, 1001, 1002)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.values(\u0026#34;ABC Store\u0026#34;, \u0026#34;123 Convenience\u0026#34;, \u0026#34;XYZ Mart\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entries(1000, \u0026#34;ABC Store\u0026#34;, 1001, \u0026#34;123 Convenience\u0026#34;, 1002, \u0026#34;XYZ Mart\u0026#34;));  val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.keys(1000, 1001, 1002) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.values(\u0026#34;ABC Store\u0026#34;, \u0026#34;123 Convenience\u0026#34;, \u0026#34;XYZ Mart\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entries(1000, \u0026#34;ABC Store\u0026#34;, 1001, \u0026#34;123 Convenience\u0026#34;, 1002, \u0026#34;XYZ Mart\u0026#34;) }   allKey(), allValue(), allEntry() # Similar to allListElement(), it is possible to set every entry within the map to the specified value with allKey(), allValue(), and allEntry().\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allKey(1000)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allValue(\u0026#34;ABC Store\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allEntry(1000, \u0026#34;ABC Store\u0026#34;));  val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allKey(1000) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allValue(\u0026#34;ABC Store\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allEntry(1000, \u0026#34;ABC Store\u0026#34;) }   keyLazy(), valueLazy(), entryLazy() # Similar to the setLazy() method in ArbitraryBuilder, you can pass a Supplier to assign the value. The Supplier will run every time the ArbitraryBuilder with the InnerSpec applied is sampled.\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.keyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.valueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entryLazy(this::generateMerchantKey, this::generateMerchantValue));  val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.keyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.valueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entryLazy(this::generateMerchantKey, this::generateMerchantValue) }   allKeyLazy(), allValueLazy(), allEntryLazy() # Just as with the allKey() method, you can use allKeyLazy() to apply keyLazy() to every entry within the map. Both allValueLazy() and allEntryLazy() function similarly.\nJava  Kotlin    InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allKeyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allValueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue));  val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allKeyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allValueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue) }   Customizing nested Maps # By combining methods within InnerSpec, you can effectively customize maps with map-type keys, map-type values, or both.\nConsider the scenario of a nested map structure like the following:\npublic class Example { Map\u0026lt;Map\u0026lt;String, String\u0026gt;, String\u0026gt; mapByString; Map\u0026lt;String, Map\u0026lt;String, String\u0026gt;\u0026gt; stringByMap; }  Setting map-type key # To set a map with a map-type key, you can access the map key using key(), and then further customize it.\ngeneral expression  Kotlin Exp    InnerSpec().property(\u0026#34;mapByString\u0026#34;, m -\u0026gt; m.key(k -\u0026gt; k.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)));  InnerSpec().property(\u0026#34;mapByString\u0026#34;) { m -\u0026gt; m.key { k -\u0026gt; k.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) } }   If you need to set the entry itself, access the entry with entry() and further customize the key using InnerSpec, then set the specific value.\ngeneral expression  Kotlin Exp    InnerSpec().property(\u0026#34;mapByString\u0026#34;, m -\u0026gt; m.entry(k -\u0026gt; k.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;)), \u0026#34;value\u0026#34;)  InnerSpec().property(\u0026#34;mapByString\u0026#34;) { m -\u0026gt; m.entry({ k -\u0026gt; k.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;) }, \u0026#34;value\u0026#34;) }   Setting map-type value # For a map with a map-type value, access the map value using value(), and then further customize it.\ngeneral expression  Kotlin Exp    InnerSpec().property(\u0026#34;stringByMap\u0026#34;, m -\u0026gt; m.value(v -\u0026gt; v.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)))  InnerSpec().property(\u0026#34;stringByMap\u0026#34;) { m -\u0026gt; m.value { v -\u0026gt; v.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) } }   If you need to set the entry itself, access the entry with entry() and further customize the value using InnerSpec, then set the specific key.\ngeneral expression  Kotlin Exp    InnerSpec().property(\u0026#34;stringByMap\u0026#34;, m -\u0026gt; m.entry(\u0026#34;key\u0026#34;, v -\u0026gt; v.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;)))  InnerSpec().property(\u0026#34;stringByMap\u0026#34;) { m -\u0026gt; m.entry(\u0026#34;key\u0026#34;) {v -\u0026gt; v.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;)} }   "}),a.add({id:17,href:"/docs/fixture-monkey-options/",title:"Fixture Monkey Options",description:"",content:""}),a.add({id:18,href:"/docs/fixture-monkey-options/concepts/",title:"Concepts",description:"Before you learn about the options Fixture Monkey provides, there are a few things you need to know.\nProperty # In the documentation, the term property is consistently used instead of field when referring to the characteristics of a class\u0026rsquo;s object. While it has the same name as \u0026lsquo;property\u0026rsquo; in Kotlin, the concept is different in Fixture Monkey.\nFixture Monkey\u0026rsquo;s initial structure was primarily based on fields, which imposed limitations on configuration and control through methods and other mechanisms.",content:"Before you learn about the options Fixture Monkey provides, there are a few things you need to know.\nProperty # In the documentation, the term property is consistently used instead of field when referring to the characteristics of a class\u0026rsquo;s object. While it has the same name as \u0026lsquo;property\u0026rsquo; in Kotlin, the concept is different in Fixture Monkey.\nFixture Monkey\u0026rsquo;s initial structure was primarily based on fields, which imposed limitations on configuration and control through methods and other mechanisms. For example, when relying solely on fields, it\u0026rsquo;s not possible to access annotations on setter methods. To address this limitation, the Property interface was introduced, which extends support beyond just fields.\nA property in Fixture Monkey, functions as a fundamental component within a class and can represent a Field, Method, or Kotlin Property. It contains information about its Type, Annotations on it, and its name.\nMoreover, in Fixture Monkey, the characteristics of both Objects and Containers are also expressed through the concept of property.\nObjectProperty # An ObjectProperty is a property that represents immutable object information. It includes:\n property: The property of the object itself. propertyNameResolver: Determines how the property name is resolved. nullInject: The probability of injecting null value. elementIndex: If the object is an element of a Container, it indicates the index. childPropertyListsByCandidateProperty: A map that holds information about child properties grouped by candidate property.  public final class ObjectProperty { private final Property property; private final PropertyNameResolver propertyNameResolver; private final double nullInject; @Nullable private final Integer elementIndex; private final Map\u0026lt;Property, List\u0026lt;Property\u0026gt;\u0026gt; childPropertyListsByCandidateProperty; }  ContainerProperty # The property of a container type is represented by ContainerProperty, which describes immutable container information. It includes:\n elementProperties: A list of element properties. containerInfo: TheArbitraryContainerInfo that determines the container\u0026rsquo;s size.  public final class ContainerProperty { private final List\u0026lt;Property\u0026gt; elementProperties; private final ArbitraryContainerInfo containerInfo; }  Options # In Fixture Monkey, several options share common characteristics. For example, let\u0026rsquo;s take a look at the options related to modifying the ObjectPropertyGenerator\n defaultObjectPropertyGenerator, pushObjectPropertyGenerator, pushAssignableTypeObjectPropertyGenerator, pushExactTypeObjectPropertyGenerator\n Options with the prefix default are applied as defaults to all properties generated by Fixture Monkey. These defaults set a basic behavior that affects all property types uniformly.\nHowever, if you need to apply specific options for a particular type, you can make use of the options that start with push. There are three variations of these push options.\n push~ : Accepts a MatcherOperator as a parameter. pushAssignableType~: This option applies the specified setting to every property type for which the given type (associated with the option) is assignable. This means that the option is applied not only to the exact given type but also to any type that can be assigned to the property type, including superclasses or superinterfaces. pushExactType~: This option limits the setting to properties with the exact same type. It does not impact properties with subtype or supertype relationships.  It\u0026rsquo;s important to note that options set using the push variants take precedence over the default options. This means that when a push option is defined for a specific type, it will override any corresponding default option for that type.\n"}),a.add({id:19,href:"/docs/fixture-monkey-options/generation-options/",title:"Generation Options",description:"To create a complex object that matches your desired configurations, Fixture Monkey provides a variety of options for creating objects.\nThese options are accessible through the FixtureMonkeyBuilder.\nProperty Generation # PropertyGenerator #  defaultPropertyGenerator, pushPropertyGenerator, pushAssignableTypePropertyGenerator, pushExactTypePropertyGenerator\n PropertyGenerator creates child properties of the given ObjectProperty. The child property can be a field, JavaBeans property, method or constructor parameter within the parent ObjectProperty. There are scenarios where you might want to customize how these child properties are generated.",content:"To create a complex object that matches your desired configurations, Fixture Monkey provides a variety of options for creating objects.\nThese options are accessible through the FixtureMonkeyBuilder.\nProperty Generation # PropertyGenerator #  defaultPropertyGenerator, pushPropertyGenerator, pushAssignableTypePropertyGenerator, pushExactTypePropertyGenerator\n PropertyGenerator creates child properties of the given ObjectProperty. The child property can be a field, JavaBeans property, method or constructor parameter within the parent ObjectProperty. There are scenarios where you might want to customize how these child properties are generated.\nThe PropertyGenerator options allow you to specify how child properties of each type are generated. This option is mainly used when you want to exclude generating some properties when the parent property has abnormal child properties.\nðŸ“–  Notable implementations: 'FieldPropertyGenerator', 'JavaBeansPropertyGenerator'   ObjectPropertyGenerator #  defaultObjectPropertyGenerator, pushObjectPropertyGenerator, pushAssignableTypeObjectPropertyGenerator, pushExactTypeObjectPropertyGenerator\n ObjectPropertyGenerator generates the ObjectProperty based on a given context. With options related to ObjectPropertyGenerator you can customize how the ObjectProperty is generated.\nðŸ“–  Notable implementations: 'DefaultObjectPropertyGenerator'   ContainerPropertyGenerator #  pushContainerPropertyGenerator, pushAssignableTypeContainerPropertyGenerator, pushExactTypeContainerPropertyGenerator\n The ContainerPropertyGenerator determines how to generate ContainerProperty within a given context. With options related to ContainerPropertyGenerator you can customize how the ContainerProperty is generated.\nðŸ“–  Notable implementations: 'ArrayContainerPropertyGenerator', 'MapContainerPropertyGenerator'    Arbitrary Generation # An Introspector determines how Fixture Monkey creates objects by selecting the appropriate arbitrary generation strategy based on the provided context(which includes information about generated properties). The object is then generated based on this arbitrary generated.\nYou have the flexibility to create a custom Introspector by implementing your own ArbitraryIntrospector.\nObjectIntrospector #  objectIntrospcetor\n The objectIntrospector option allows you to specify the default behavior when generating an object. As discussed in the introspector section, you can alter the default introspector to use predefined introspectors provided by Fixture Monkey or create your own custom introspector.\nðŸ“–  Notable implementations: 'BeanArbitraryIntrospector', 'BuilderArbitraryIntrospector'   ArbitraryIntrospector #  pushArbitraryIntrospector, pushAssignableTypeArbitraryIntrospector, pushExactTypeArbitraryIntrospector\n If you need to change the ArbitraryIntrospector for a specific type you can use the above options.\nðŸ“–  Notable implementations: 'BooleanIntrospector', 'EnumIntrospector'   ContainerIntrospector #  pushContainerIntrospector\n Especially for container types, you can change the ArbitraryIntrospector using the pushContainerIntrospector option.\nðŸ“–  Notable implementations: 'ListIntrospector', 'MapIntrospector'    Arbitrary Generation # The ArbitraryIntrospector is responsible for defining how Fixture Monkey creates objects by selecting the appropriate arbitrary generation strategy and generating an arbitrary. The actual creation of the final arbitrary(CombinableArbitrary) from the arbitrary is done by the ArbitraryGenerator, which handles the request by delegating to the ArbitraryIntrospcetor. By using the defaultArbitraryGenerator option, you have the capability to customize the behavior of the ArbitraryGenerator.\nFor instance, you can create an arbitrary generator that produces unique values, as shown in the example below:\nJava  Kotlin    public static class UniqueArbitraryGenerator implements ArbitraryGenerator { private static final Set\u0026lt;Object\u0026gt; UNIQUE = new HashSet\u0026lt;\u0026gt;(); private final ArbitraryGenerator delegate; public UniqueArbitraryGenerator(ArbitraryGenerator delegate) { this.delegate = delegate; } @Override public CombinableArbitrary generate(ArbitraryGeneratorContext context) { return delegate.generate(context) .filter( obj -\u0026gt; { if (!UNIQUE.contains(obj)) { UNIQUE.add(obj); return true; } return false; } ); } } FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryGenerator(UniqueArbitraryGenerator::new) .build();  class UniqueArbitraryGenerator(private val delegate: ArbitraryGenerator) : ArbitraryGenerator { companion object { private val UNIQUE = HashSet\u0026lt;Any\u0026gt;() } override fun generate(context: ArbitraryGeneratorContext): CombinableArbitrary { return delegate.generate(context) .filter { obj -\u0026gt; if (!UNIQUE.contains(obj)) { UNIQUE.add(obj) true } else { false } } } } val fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryGenerator { UniqueArbitraryGenerator(it) } .build()   ðŸ“–  Notable implementations: 'IntrospectedArbitraryGenerator', 'CompositeArbitraryGenerator'    Excluding Classes or Packages from Generation #  pushExceptGenerateType, addExceptGenerateClass, addExceptGenerateClasses, addExceptGeneratePackage, addExceptGeneratePackages\n If you want to exclude the generation of certain types or packages, you can use these options.\nJava  Kotlin    @Test void testExcludeClass() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addExceptGenerateClass(String.class) .build(); String actual = sut.giveMeOne(Product.class) .getProductName(); then(actual).isNull(); } @Test void testExcludePackage() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addExceptGeneratePackage(\u0026#34;java.lang\u0026#34;) .build(); String actual = sut.giveMeOne(String.class); then(actual).isNull(); }  @Test fun testExcludeClass() { val fixtureMonkey = FixtureMonkey.builder() .addExceptGenerateClass(String::class.java) .build() val actual = fixtureMonkey.giveMeOne\u0026lt;Product\u0026gt;() .productName then(actual).isNull() } @Test fun testExcludePackage() { val fixtureMonkey = FixtureMonkey.builder() .addExceptGeneratePackage(\u0026#34;java.lang\u0026#34;) .build() val actual = fixtureMonkey.giveMeOne\u0026lt;String\u0026gt;() then(actual).isNull() }    Container options # Container Size #  defaultArbitraryContainerInfoGenerator, pushArbitraryContainerInfoGenerator\n ArbitraryContainerInfo holds information about the minimum and maximum sizes of a Container type. You can change the behavior by modifying the ArbitraryContainerInfoGenerator using related options.\nThe following example demonstrates how to customize ArbitraryContainerInfo to set the size of all container types to 3.\nJava  Kotlin    @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator(context -\u0026gt; new ArbitraryContainerInfo(3, 3)) .build(); List\u0026lt;String\u0026gt; actual = fixtureMonkey.giveMeOne(); then(actual).hasSize(3); }  @Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator { context -\u0026gt; ArbitraryContainerInfo(3, 3) } .build() val actual: List\u0026lt;String\u0026gt; = fixtureMonkey.giveMeOne() then(actual).hasSize(3) }   Adding Container type #  addContainerType\n You can add a new custom Container type using the addContainerType option.\nLet\u0026rsquo;s say you made a new custom Pair class in Java.\nYou can use this container type by implementing a custom ContainerPropertyGenerator, Introspector and DecomposedContainerValueFactory.\nFixtureMonkey fixtureMonkey=FixtureMonkey.builder() .addContainerType( Pair.class, new PairContainerPropertyGenerator(), new PairIntrospector(), new PairDecomposedContainerValueFactory() ) .build();  custom Introspector:\npublic class PairIntrospector implements ArbitraryIntrospector, Matcher { private static final Matcher MATCHER = new AssignableTypeMatcher(Pair.class); @Override public boolean match(Property property) { return MATCHER.match(property); } @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { ArbitraryProperty property = context.getArbitraryProperty(); ArbitraryContainerInfo containerInfo = property.getContainerProperty().getContainerInfo(); if (containerInfo == null) { return ArbitraryIntrospectorResult.EMPTY; } List\u0026lt;Arbitrary\u0026lt;?\u0026gt;\u0026gt; childrenArbitraries = context.getChildrenArbitraryContexts().getArbitraries(); BuilderCombinator\u0026lt;List\u0026lt;Object\u0026gt;\u0026gt; builderCombinator = Builders.withBuilder(ArrayList::new); for (Arbitrary\u0026lt;?\u0026gt; childArbitrary : childrenArbitraries) { builderCombinator = builderCombinator.use(childArbitrary).in((list, element) -\u0026gt; { list.add(element); return list; }); } return new ArbitraryIntrospectorResult( builderCombinator.build(it -\u0026gt; new Pair\u0026lt;\u0026gt;(it.get(0), it.get(1))) ); } }  custom ContainerPropertyGenerator:\npublic class PairContainerPropertyGenerator implements ContainerPropertyGenerator { @Override public ContainerProperty generate(ContainerPropertyGeneratorContext context) { com.navercorp.fixturemonkey.api.property.Property property = context.getProperty(); List\u0026lt;AnnotatedType\u0026gt; elementTypes = Types.getGenericsTypes(property.getAnnotatedType()); if (elementTypes.size() != 2) { throw new IllegalArgumentException( \u0026quot;Pair elementsTypes must be have 1 generics type for element. \u0026quot; + \u0026quot;propertyType: \u0026quot; + property.getType() + \u0026quot;, elementTypes: \u0026quot; + elementTypes ); } AnnotatedType firstElementType = elementTypes.get(0); AnnotatedType secondElementType = elementTypes.get(1); List\u0026lt;com.navercorp.fixturemonkey.api.property.Property\u0026gt; elementProperties = new ArrayList\u0026lt;\u0026gt;(); elementProperties.add( new ElementProperty( property, firstElementType, 0, 0 ) ); elementProperties.add( new ElementProperty( property, secondElementType, 1, 1 ) ); return new ContainerProperty( elementProperties, new ArbitraryContainerInfo(1, 1, false) ); } }  custom DecomposedContainerValueFactory:\npublic class PairDecomposedContainerValueFactory implements DecomposedContainerValueFactory { @Override public DecomposedContainerValue from(Object object) { Pair\u0026lt;?, ?\u0026gt; pair = (Pair\u0026lt;?, ?\u0026gt;)obj; List\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(pair.getFirst()); list.add(pair.getSecond()); return new DecomposableContainerValue(list, 2); } }   Validating Arbitraries #  arbitraryValidator\n The arbitraryValidator option allows you to replace the default arbitraryValidator with your own custom arbitrary validator.\nWhen an instance is sampled, the arbitraryValidator validates the arbitrary, and if it is invalid, it throws an exception. This process is repeated 1,000 times, and if the instance is still invalid, a TooManyFilterMissesException would be thrown.\nðŸ“–  Notable implementations: 'JakartaArbitraryValidator', 'JavaxArbitraryValidator'   Java  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .arbitraryValidator(obj -\u0026gt; { throw new ValidationFailedException(\u0026#34;thrown by custom ArbitraryValidator\u0026#34;, new HashSet\u0026lt;\u0026gt;()); }) .build(); thenThrownBy(() -\u0026gt; fixtureMonkey.giveMeOne(String.class)) .isExactlyInstanceOf(FilterMissException.class);  val fixtureMonkey = FixtureMonkey.builder() .arbitraryValidator { obj -\u0026gt; throw ValidationFailedException(\u0026#34;thrown by custom ArbitraryValidator\u0026#34;, HashSet()) } .build() assertThatThrownBy { fixtureMonkey.giveMeOne\u0026lt;String\u0026gt;() } .isExactlyInstanceOf(FilterMissException::class.java)    Arbitrary Generation Retry Limits #  generateMaxTries, generateUniqueMaxTries\n The generateMaxTries option allows you to control the maximum number of attempts to generate a valid object from an arbitrary. If an object cannot be generated successfully after exceeding this limit (default is 1,000 attempts), a TooManyFilterMissesException will be thrown.\nAdditionally, Fixture Monkey ensures the generation of unique values for map keys and set elements. The generateUniqueMaxTries option allows you to specify the maximum number of attempts (also defaults to 1,000) that will be made to generate this unique value.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .generateMaxTries(100) .generateUniqueMaxTries(100) .build();  val fixtureMonkey = FixtureMonkey.builder() .generateMaxTries(100) .generateUniqueMaxTries(100) .build()    Interface Implementations #  interfaceImplements\n interfaceImplements is an option used to specify the available implementations for an interface.\nWhen you don\u0026rsquo;t specify this option, an ArbitraryBuilder for an interface will always result in a null value when sampled. However, when you do specify this option, Fixture Monkey will randomly generate one of the specified implementations whenever an ArbitraryBuilder for the interface is sampled.\nJava  Kotlin    interface FixedValue { Object get(); } class IntegerFixedValue implements FixedValue { @Override public Object get() { return 1; } } class StringFixedValue implements FixedValue { @Override public Object get() { return \u0026#34;fixed\u0026#34;; } } class GenericFixedValue\u0026lt;T\u0026gt; { T value; } @Test void sampleGenericInterface() { // given  List\u0026lt;Class\u0026lt;? extends FixedValue\u0026gt;\u0026gt; implementations = new ArrayList\u0026lt;\u0026gt;(); implementations.add(IntegerFixedValue.class); implementations.add(StringFixedValue.class); FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .interfaceImplements(FixedValue.class, implementations) .build(); // when  Object actual = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;GenericGetFixedValue\u0026lt;FixedValue\u0026gt;\u0026gt;() {}) .setNotNull(\u0026#34;value\u0026#34;) .sample() .getValue() .get(); // then  then(actual).isIn(1, \u0026#34;fixed\u0026#34;); }  interface FixedValue { fun get(): Any } class IntegerFixedValue : FixedValue { override fun get(): Any { return 1 } } class StringFixedValue : FixedValue { override fun get(): Any { return \u0026#34;fixed\u0026#34; } } class GenericFixedValue\u0026lt;T\u0026gt; { val value: T } @Test fun sampleGenericInterface() { // given  val implementations: MutableList\u0026lt;Class\u0026lt;out FixedValue\u0026gt;\u0026gt; = List.of(IntegerFixedValue::class.java, StringFixedValue::class.java) val fixtureMonkey = FixtureMonkey.builder() .interfaceImplements(FixedValue::class.java, implementations) .build() // when  val actual = fixtureMonkey.giveMeBuilder\u0026lt;GenericGetFixedValue\u0026lt;FixedValue\u0026gt;\u0026gt;() .sample() .getValue() .get() // then  then(actual).isIn(1, \u0026#34;fixed\u0026#34;) }   "}),a.add({id:20,href:"/docs/fixture-monkey-options/customization-options/",title:"Customization Options",description:"Fixture Monkey also provides options through the FixtureMonkeyBuilder to customize objects to have the desired values or to use custom property names.\nPropertyNameResolver #  defaultPropertyNameResolver, pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, pushExactTypePropertyNameResolver\n Options related to the PropertyNameResolver allow you to customize how you refer to your properties.\nThe defaultPropertyNameResolver option is used to change the way property names are figured out for all types. If you want to make specific changes for certain types, you can use pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, or pushExactTypePropertyNameResolver.",content:"Fixture Monkey also provides options through the FixtureMonkeyBuilder to customize objects to have the desired values or to use custom property names.\nPropertyNameResolver #  defaultPropertyNameResolver, pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, pushExactTypePropertyNameResolver\n Options related to the PropertyNameResolver allow you to customize how you refer to your properties.\nThe defaultPropertyNameResolver option is used to change the way property names are figured out for all types. If you want to make specific changes for certain types, you can use pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, or pushExactTypePropertyNameResolver.\nBy default, a property will be referenced by its original name. Let\u0026rsquo;s take a look at the following example to see how we can customize the property name:\nJava  Kotlin    @Data // getter, setter public class Product { String productName; } @Test void test() { // given  FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushPropertyNameResolver(MatcherOperator.exactTypeMatchOperator(String.class, (property) -\u0026gt; \u0026#34;string\u0026#34;)) .build(); String expected = \u0026#34;test\u0026#34;; // when  String actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;string\u0026#34;, expected) .sample() .getProductName(); // then  then(actual).isEqualTo(expected); }  data class Product ( val productName: String ) @Test fun test() { // given  val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .pushPropertyNameResolver( MatcherOperator.exactTypeMatchOperator(String::class.java, PropertyNameResolver { \u0026#34;string\u0026#34; }) ) .build() val expected = \u0026#34;test\u0026#34; // when  val actual: String = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;string\u0026#34;, expected) .sample() .productName // then  then(actual).isEqualTo(expected) }   Normally, the property name will resolve to the original property name \u0026ldquo;productName\u0026rdquo;. However, with pushPropertyNameResolver the String type properties are now referred to by the name \u0026ldquo;string\u0026rdquo;.\nRegister #  register, registerGroup, registerExactType, registerAssignableType\n Sometimes your class may need to consistently match certain constraints. It can be inconvenient and result in lengthy code if you always have to modify the ArbitraryBuilder using customization APIs. In such cases, you can set a default ArbitraryBuilder for a class that will satisfy all the basic constraints.\nThe register option helps to register an ArbitraryBuilder for a specific type.\nFor example, the following code demonstrates how to register an ArbitraryBuilder for a Product class. By doing so, all Product instances created by FixtureMonkey will have an id value greater than or equal to \u0026ldquo;0\u0026rdquo;.\nJava  Kotlin    FixtureMonkey.builder() .register( Product.class, fixture -\u0026gt; fixture.giveMeBuilder(Product.class) .set(\u0026#34;id\u0026#34;, Arbitraries.longs().greaterOrEqual(0)) ) .build();  FixtureMonkey.builder() .register(Product::class.java) { it.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;id\u0026#34;, Arbitraries.longs().greaterOrEqual(0)) } .build()   If you want to register several ArbitraryBuilders at once, you can use the registerGroup option. This can be done using either reflection or the ArbitraryBuilderGroup interface.\nUsing reflection: Java  Kotlin    public class GenerateGroup { public ArbitraryBuilder\u0026lt;GenerateString\u0026gt; generateString(FixtureMonkey fixtureMonkey) { return fixtureMonkey.giveMeBuilder(GenerateString.class) .set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()); } public ArbitraryBuilder\u0026lt;GenerateInt\u0026gt; generateInt(FixtureMonkey fixtureMonkey) { return fixtureMonkey.giveMeBuilder(GenerateInt.class) .set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)); } } FixtureMonkey.builder() .registerGroup(GenerateGroup.class) .build();  class GenerateGroup { fun generateString(fixtureMonkey: FixtureMonkey): ArbitraryBuilder\u0026lt;GenerateString\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;GenerateString\u0026gt;() .set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()) } fun generateInt(fixtureMonkey: FixtureMonkey): ArbitraryBuilder\u0026lt;GenerateInt\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;GenerateInt\u0026gt;() .set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)) } } FixtureMonkey.builder() .registerGroup(GenerateGroup::class.java) .build()   Using ArbitraryBuilderGroup interface:\nJava  Kotlin    public class GenerateBuilderGroup implements ArbitraryBuilderGroup { @Override public ArbitraryBuilderCandidateList generateCandidateList() { return ArbitraryBuilderCandidateList.create() .add( ArbitraryBuilderCandidateFactory.of(GenerateString.class) .builder( arbitraryBuilder -\u0026gt; arbitraryBuilder .set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()) ) ) .add( ArbitraryBuilderCandidateFactory.of(GenerateInt.class) .builder( builder -\u0026gt; builder .set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)) ) ); } } FixtureMonkey.builder() .registerGroup(new GenerateBuilderGroup()) .build();  class GenerateBuilderGroup : ArbitraryBuilderGroup { override fun generateCandidateList(): ArbitraryBuilderCandidateList { return ArbitraryBuilderCandidateList.create() .add( ArbitraryBuilderCandidateFactory.of(GenerateString::class.java) .builder { it.set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()) } ) .add( ArbitraryBuilderCandidateFactory.of(GenerateInt::class.java) .builder { it.set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)) } ) } } FixtureMonkey.builder() .registerGroup(GenerateBuilderGroup()) .build()   Expression Strict Mode #  useExpressionStrictMode\n When using expressions (especially String Expressions), it\u0026rsquo;s hard to know if the expression you\u0026rsquo;ve written has a matching property, and the property is correctly adjusted. Using the useExpressionStrictMode option will throw an IllegalArgumentException if the expression you wrote doesn\u0026rsquo;t have a matching property.\nJava  Kotlin    @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder().useExpressionStrictMode().build(); thenThrownBy( () -\u0026gt; fixtureMonkey.giveMeBuilder(String.class) .set(\u0026#34;nonExistentField\u0026#34;, 0) .sample() ).isExactlyInstanceOf(IllegalArgumentException.class) .hasMessageContaining(\u0026#34;No matching results for given NodeResolvers.\u0026#34;); }  @Test fun test() { val fixtureMonkey = FixtureMonkey.builder().useExpressionStrictMode().build() assertThatThrownBy { fixtureMonkey.giveMeBuilder\u0026lt;String\u0026gt;() .set(\u0026#34;nonExistentField\u0026#34;, 0) .sample() }.isExactlyInstanceOf(IllegalArgumentException::class.java) .hasMessageContaining(\u0026#34;No matching results for given NodeResolvers.\u0026#34;) }   Constraining Java types #  javaTypeArbitraryGenerator, javaTimeTypeArbitraryGenerator\n You can modify the default values for Java primitive types (such as strings, integers, doubles, etc.) by implementing a custom JavaTypeArbitraryGenerator interface.\nFor example, by default, string types generated with Fixture Monkey have unreadable data because it considers edge cases such as when control blocks are contained in strings.\nIf you prefer to generate strings consisting only of alphabetic characters, you can override the JavaTypeArbitraryGenerator as demonstrated below:\nJava  Kotlin    FixtureMonkey.builder() .javaTypeArbitraryGenerator(new JavaTypeArbitraryGenerator() { @Override public StringArbitrary strings() { return Arbitraries.strings().alpha(); } }) .build();  FixtureMonkey.builder() .javaTypeArbitraryGenerator(object : JavaTypeArbitraryGenerator { override fun strings(): StringArbitrary = Arbitraries.strings().alpha() }) .build()   For Java time types, you can use javaTimeTypeArbitraryGenerator.\nConstraining Java types with annotations #  javaArbitraryResolver, javaTimeArbitraryResolver\n Similar to using the javax-validation plugin and adding constraints to your Java typed properties, you can apply constraints to Java types using annotations. To do this, you can implement a JavaArbitraryResolver interface.\nFor example, if you have a custom annotation named MaxLengthOf10, which means that the length of a property should be limited to a maximum of 10 characters, you can create a JavaArbitraryResolver as shown below:\nJava  Kotlin    FixtureMonkey.builder() .javaArbitraryResolver(new JavaArbitraryResolver() { @Override public Arbitrary\u0026lt;String\u0026gt; strings(StringArbitrary stringArbitrary, ArbitraryGeneratorContext context) { if (context.findAnnotation(MaxLengthof10.class).isPresent()) { return stringArbitrary.ofMaxLength(10); } return stringArbitrary; } }) .build();  FixtureMonkey.builder() .javaArbitraryResolver(object : JavaArbitraryResolver { override fun strings(stringArbitrary: StringArbitrary, context: ArbitraryGeneratorContext): Arbitrary\u0026lt;String\u0026gt; { if (context.findAnnotation(MaxLengthof10::class.java).isPresent) { return stringArbitrary.ofMaxLength(10) } return stringArbitrary } }) .build()   Null Options # defaultNotNull #  defaultNotNull, nullableContainer, nullableElement\n When you want to ensure that the properties of your instance are not null, you can utilize the options mentioned below.\n defaultNotNull determines whether a null property is generated. If true, property cannot be null nullableContainer determines whether a container property can be null. If true, container can be null nullableElement determines whether an element within a container property can be null. If true, element can be null.  By default, these three options are set to false. You can modify them to true as needed.\nðŸš¨  These options only apply to properties that do not have a nullable marker, such as @Nullable in Java or ? in Kotlin.   Java  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder().defaultNotNull(true).build(); FixtureMonkey fixtureMonkey = FixtureMonkey.builder().nullableContainer(true).build(); FixtureMonkey fixtureMonkey = FixtureMonkey.builder().nullableElement(true).build();  val fixtureMonkey = FixtureMonkey.builder().defaultNotNull(true).build() val fixtureMonkey = FixtureMonkey.builder().nullableContainer(true).build() val fixtureMonkey = FixtureMonkey.builder().nullableElement(true).build()    NullInjectGenerator #  defaultNullInjectGenerator, pushNullInjectGenerator, pushExactTypeNullInjectGenerator, pushAssignableTypeNullInjectGenerator\n In cases where a property should be null regardless of any nullable markers, you can make use of the options associated with the NullInjectGenerator.\nThe defaultnullInjectGenerator option allows you to set the probability of properties being null.\nBy default, the probability of a property being null is set to 20%.\nIf you want it to always be null, you can set it to 1.0d. There are predefined values available in the DefaultNullInjectGeneratorâ€”NOT_NULL_INJECT(0.0d) and ALWAYS_NULL_INJECT(1.0d)â€”which you can import and use.\nAlternatively, for more customized behavior, you can implement your own NullInjectGenerator.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultNullInjectGenerator((context) -\u0026gt; NOT_NULL_INJECT) // you can use NOT_NULL_INJECT or write your probability as 0.4  .build()  val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .defaultNullInjectGenerator { NOT_NULL_INJECT } // you can use NOT_NULL_INJECT or write your probability as 0.4  .build()   If you want to specifically change the probability of a certain type being null, you can use pushNullInjectGenerator.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushNullInjectGenerator(MatcherOperator.exactTypeMatchOperator(SimpleObject.class, (context) -\u0026gt; NOT_NULL_INJECT)) .build();  val fixtureMonkey = FixtureMonkey.builder() .pushNullInjectGenerator( exactTypeMatchOperator( Product::class.java, NullInjectGenerator { context -\u0026gt; NOT_NULL_INJECT } ) ) .build()   Registering an ArbitraryBuilder of a specific class with register that has the .setNotNull(\u0026quot;*\u0026quot;) setting will have the same effect.\n"}),a.add({id:21,href:"/docs/fixture-monkey-options/other-options/",title:"Other Options",description:"This section explains some additional options that the FixtureMonkeyBuilder provide.\nplugin # Fixture Monkey offers several additional features, including support for third-party libraries through plugins. You can use the plugin option to use these additional features.\nFor example, you can add the Jackson plugin as shown below. This will allow you to use Jackson features such as JacksonObjectArbitraryIntrospector and Jackson annotation support.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.",content:"This section explains some additional options that the FixtureMonkeyBuilder provide.\nplugin # Fixture Monkey offers several additional features, including support for third-party libraries through plugins. You can use the plugin option to use these additional features.\nFor example, you can add the Jackson plugin as shown below. This will allow you to use Jackson features such as JacksonObjectArbitraryIntrospector and Jackson annotation support.\nJava  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build();  val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build()   "}),a.add({id:22,href:"/docs/plugins/",title:"Plugins",description:"",content:""}),a.add({id:23,href:"/docs/plugins/kotlin-plugin/",title:"Kotlin Plugin",description:"",content:""}),a.add({id:24,href:"/docs/plugins/kotlin-plugin/features/",title:"Features",description:"To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.\n Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp  Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-kotlin-starter that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.",content:"To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.\n Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp  Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-kotlin-starter that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.\nGradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-starter-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build()  "}),a.add({id:25,href:"/docs/plugins/kotlin-plugin/introspectors-for-kotlin/",title:"Introspectors for Kotlin",description:"Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.\nPrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.\nExample Kotlin Class :\ndata class Product ( val id: Long?, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant )  Using PrimaryConstructorArbitraryIntrospector :\n@Test fun test() { val fixtureMonkey = FixtureMonkey.",content:"Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.\nPrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.\nExample Kotlin Class :\ndata class Product ( val id: Long?, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant )  Using PrimaryConstructorArbitraryIntrospector :\n@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() val product: Product = fixtureMonkey.giveMeOne() }  "}),a.add({id:26,href:"/docs/plugins/kotlin-plugin/kotlin-exp/",title:"Kotlin DSL Exp",description:"Fixture Monkey utilizes Kotlin\u0026rsquo;s DSL feature to ensure type-safety with expressions. Let\u0026rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.\nReferencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:\n@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested nestedObject; List\u0026lt;Nested\u0026gt; nestedObjectList; @Value public static class Nested { String nestedField; } }  data class KotlinClass( val field: String, val list: List\u0026lt;String\u0026gt;, val nestedObject: Nested, val nestedObjectList: List\u0026lt;Nested\u0026gt; ) { data class Nested( val nestedField: String ) }  To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal [Fixture Customization APIs]((.",content:"Fixture Monkey utilizes Kotlin\u0026rsquo;s DSL feature to ensure type-safety with expressions. Let\u0026rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.\nReferencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:\n@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested nestedObject; List\u0026lt;Nested\u0026gt; nestedObjectList; @Value public static class Nested { String nestedField; } }  data class KotlinClass( val field: String, val list: List\u0026lt;String\u0026gt;, val nestedObject: Nested, val nestedObjectList: List\u0026lt;Nested\u0026gt; ) { data class Nested( val nestedField: String ) }  To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal [Fixture Customization APIs]((../../customizing-objects/apis).\nLet\u0026rsquo;s look at the example of customizing properties with Kotlin Exp using setExp() and setExpGetter().\n@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder\u0026lt;JavaClass\u0026gt;() .setExpGetter(JavaClass::getField, \u0026quot;field\u0026quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder\u0026lt;KotlinClass\u0026gt;() .setExp(KotlinClass::field, \u0026quot;field\u0026quot;) .sample() // then then(javaClass.field).isEqualTo(\u0026quot;field\u0026quot;) then(kotlinClass.field).isEqualTo(\u0026quot;field\u0026quot;) }  In the code above, we can see that we are using Kotlin\u0026rsquo;s method reference to select a property.\nsetExp() takes an argument of type KProperty, while setExpGetter() takes an argument of type KFunction.\nIf the class is defined in Java, the expression (e.g. JavaClass::getField) is of type KFunction because it is a reference to a Java getter. Therefore you can only use the setExpGetter() method.\nIf it is a Kotlin class, the expression (e.g. KotlinClass::field) is KProperty, so you should use setExp().\nReferencing a nested property # To access a nested field, the infix functions into and intoGetter are used. into takes a parameter of type KProperty, while intoGetter takes a parameter of type KFunction.\n@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder\u0026lt;JavaClass\u0026gt;() .setExp(JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField, \u0026quot;nestedField\u0026quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder\u0026lt;KotlinClass\u0026gt;() .setExp(KotlinClass::nestedObject into KotlinClass.Nested::nestedField, \u0026quot;nestedField\u0026quot;) .sample() then(javaClass.nestedObject.nestedField).isEqualTo(\u0026quot;nestedField\u0026quot;) then(kotlinClass.nestedObject.nestedField).isEqualTo(\u0026quot;nestedField\u0026quot;) }  An expression that contains an into or intoGetter operator becomes an ExpressionGenerator type in fixture monkey. Both setExp() and setExpGetter()) are defined to take ExpressionGenerator types as arguments, so you can use both.\n Selecting Properties Using Kotlin DSL Expressions # Selecting the root object: #  Currently Not Supported  Selecting a specific field: # JavaClass::getField // java class KotlinClass::field // kotlin class  Selecting a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class  Selecting the n-th element of a collection: # JavaClass::getNestedObjectList[\u0026quot;0\u0026quot;] // java class KotlinClass::nestedObjectList[\u0026quot;0\u0026quot;] // kotlin class  Selecting all elements of a collection: # JavaClass::getNestedObjectList[\u0026quot;*\u0026quot;] // java class KotlinClass::nestedObjectList[\u0026quot;*\u0026quot;] // kotlin class  Combining expressions to select a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class  "}),a.add({id:27,href:"/docs/plugins/jackson-plugin/",title:"Jackson Plugin",description:"",content:""}),a.add({id:28,href:"/docs/plugins/jackson-plugin/features/",title:"Features",description:"Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.\n Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty  Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin # Java  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build();  val fixtureMonkey = FixtureMonkey.",content:"Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.\n Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty  Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin # Java  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build();  val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build()   Pass the object mapper to the JacksonPlugin constructor if you are using Jackson with a custom object mapper.\nJava  Kotlin    ObjectMapper objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin(objectMapper)) .build();  val objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin(objectMapper)) .build()   "}),a.add({id:29,href:"/docs/plugins/jackson-plugin/jackson-object-arbitrary-introspector/",title:"JacksonObjectArbitraryIntrospector",description:"JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson\u0026rsquo;s object mapper.\nExample Java Class :\n@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; }  Using JacksonObjectArbitraryIntrospector : Java  Kotlin    @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.",content:"JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson\u0026rsquo;s object mapper.\nExample Java Class :\n@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; }  Using JacksonObjectArbitraryIntrospector : Java  Kotlin    @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); Product product = fixtureMonkey.giveMeOne(Product.class); }  testImplementation(\u0026#34;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:0.6.8\u0026#34;) testImplementation(\u0026#34;com.fasterxml.jackson.module:jackson-module-kotlin\u0026#34;) @Test fun test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build(); val product: Product = fixtureMonkey.giveMeOne() }   ðŸ’¡  To generate Kotlin classes with JacksonObjectArbitraryIntrospector, both Kotlin plugin and Jackson plugin need to be added. In addition, fasterxml jackson-module-kotlin should be added to the dependency for serialization/deserialization of Kotlin classes.   It has the advantage of being a general purpose introspector because it relies on the widely used Jackson for object creation. If your production code has both Kotlin and Java classes, it is recommended to use JacksonObjectArbitraryIntrospector.\nHowever, it does have the disadvantage of potentially not performing as efficiently as other introspectors, as deserialization with Jackson can be more time-consuming.\n"}),a.add({id:30,href:"/docs/plugins/jackson-plugin/jackson-annotations/",title:"Jackson Annotations",description:"With the Jackson plugin, some Jackson annotations are also supported.\n@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.\nThe property with @JsonIgnore will have a null value when Fixture Monkey generates the object.\nThe following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.\nExample Java Class :\n@Value // lombok getter, setter public class Product { long id; @JsonProperty(\u0026quot;name\u0026quot;) String productName; long price; @JsonIgnore List\u0026lt;String\u0026gt; options; Instant createdAt; }  Java  Kotlin    @Test void test() { // given  FixtureMonkey fixtureMonkey = FixtureMonkey.",content:"With the Jackson plugin, some Jackson annotations are also supported.\n@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.\nThe property with @JsonIgnore will have a null value when Fixture Monkey generates the object.\nThe following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.\nExample Java Class :\n@Value // lombok getter, setter public class Product { long id; @JsonProperty(\u0026quot;name\u0026quot;) String productName; long price; @JsonIgnore List\u0026lt;String\u0026gt; options; Instant createdAt; }  Java  Kotlin    @Test void test() { // given  FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); // when  Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;name\u0026#34;, \u0026#34;book\u0026#34;) .sample(); // then  then(actual.getProductName()).isEqualTo(\u0026#34;book\u0026#34;); // @JsonProperty  then(actual.getOptions()).isNull(); // @JsonIgnore }  @Test fun test() { // given  val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() // when  val actual = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;name\u0026#34;, \u0026#34;book\u0026#34;) .sample() // then  then(actual.productName).isEqualTo(\u0026#34;book\u0026#34;) // @JsonProperty  then(actual.options).isNull() // @JsonIgnore }   @JsonTypeInfo, @JsonSubTypes # Fixture Monkey also supports Jackson\u0026rsquo;s polymorphic type handling annotations @JsonTypeInfo and @JsonSubTypes.\nWe can generate an inheritance-implementation relationship object with the help of FixtureMonkey.\n"}),a.add({id:31,href:"/docs/plugins/jakarta-validation-plugin/",title:"Jakarta Validation Plugin",description:"",content:""}),a.add({id:32,href:"/docs/plugins/jakarta-validation-plugin/features/",title:"Features",description:"Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.\nðŸ’¡  Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin   Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:jakarta-validation:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  The jakarta validation API and the Hibernate validator are already provided as part of the dependency.\nPlugin # Java  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.",content:"Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.\nðŸ’¡  Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin   Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:jakarta-validation:0.6.8\u0026quot;)  Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.6.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  The jakarta validation API and the Hibernate validator are already provided as part of the dependency.\nPlugin # Java  Kotlin    FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) .build();  val fixtureMonkey = FixtureMonkey.builder() .plugin(JakartaValidationPlugin()) .build()   "}),a.add({id:33,href:"/docs/plugins/jakarta-validation-plugin/bean-validation/",title:"Bean Validation",description:"Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.\nFor example, there can be a `Product' class annotated as follows:\n@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; }  An instance of the Product class that is compliant with the annotations can be created in the following manner::",content:"Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.\nFor example, there can be a `Product' class annotated as follows:\n@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; }  An instance of the Product class that is compliant with the annotations can be created in the following manner::\n@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -\u0026gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); }  Supported Annotations # Every annotation from the jakarta.validation.constraints package is supported. Different types support different annotation constraints.\nNumeric Type # Supported Types: BigDecimal, BigInteger, byte, double, float, int, long, short\n @Digits (fraction is currently not supported) @Max @Min @Negative @NegativeOrZero @DecimalMax @DecimalMin @Positive @PositiveOrZero  Boolean Type #  @AssertFalse @AssertTrue  String Type #  @Null @NotNull @NotBlank @NotEmpty @Size @Digits @Pattern @Email  Time Type # Supported Types: Calendar, Date, Instant, LocalDate, LocalDateTime, LocalTime, ZonedDateTime, Year, YearMonth, MonthDay, OffsetDateTime, OffsetTime\n @Past @PastOrPresent @Future @FutureOrPresent  Container Type #  @Size @NotEmpty  "}),a.add({id:34,href:"/docs/intellij-plugin/",title:"Intellij Plugin",description:"",content:""}),a.add({id:35,href:"/docs/intellij-plugin/fixture-monkey-helper/",title:"Fixture Monkey Helper",description:"Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.\nIt provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.\nFeatures #   Fixture Monkey String Expression support\n Conversion of String Expressions to Fixture Monkey Kotlin DSL Expression validation Auto completion Go to target field (reference)    FixtureMonkey Kotlin DSL support",content:"Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.\nIt provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.\nFeatures #   Fixture Monkey String Expression support\n Conversion of String Expressions to Fixture Monkey Kotlin DSL Expression validation Auto completion Go to target field (reference)    FixtureMonkey Kotlin DSL support\n Convert Kotlin DSL to Fixture Monkey String Expression Folding to Fixture Monkey String Expression Generate Kotlin Lambda expression that helps define Fixture specification easily Convert Lambda to Fixture Monkey Kotlin DSL    Inspection\n Change type information passed as method arguments in Fixture Monkey factory methods to generic type arguments Change generic type arguments to variable types in Fixture Monkey factory methods when possible    "}),a.add({id:36,href:"/docs/",title:"Docs",description:"",content:""}),search.addEventListener('input',b,!0);function b(){var b,e;const d=4,f=300;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[i,h]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href="/fixture-monkey"+i,b.appendChild(a);const e=document.createElement('span');e.textContent=h.title,e.classList.add("suggestion__title"),a.appendChild(e);const g=document.createElement('span');if(g.textContent=h.description.substring(0,f),g.classList.add("suggestion__description"),a.appendChild(g),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()